# 블록체인 프로젝트 수정 내역

## 1. `Wallet.java`

### 문제점
- `sendFunds` 메소드가 거래에 사용할 UTXO를 지갑 소유 여부와 관계없이 블록체인의 모든 UTXO 중에서 가져오는 오류가 있었습니다.
- `sendFunds` 메소드가 아직 블록에 포함되지 않은 거래의 UTXO를 전체 UTXO 목록(`BlockChain.UTXOs`)에서 미리 제거하여, 이후 트랜잭션 검증 과정(`processTransaction`)이 실패하는 원인이 되었습니다.

### 수정 내용
- 각 `Wallet` 인스턴스가 자신의 UTXO만 저장하는 `HashMap<String,TransactionOutput> UTXOs`를 갖도록 수정했습니다.
- `getBalance()`: 이제 전체 UTXO 목록을 순회하며 해당 지갑 소유의 UTXO를 식별하고, 이를 지갑의 `UTXOs` 맵에 저장하며 잔액을 계산합니다.
- `sendFunds()`: 거래 시 자금 출처를 전역 `BlockChain.UTXOs`가 아닌 지갑 소유의 `UTXOs` 맵에서만 찾도록 수정했습니다. 또한, 사용된 UTXO를 지갑의 `UTXOs` 맵에서만 제거하도록 변경했습니다.

```java
// 수정 전
public Transaction sendFunds(PublicKey _recipient, float value) {
    // ...
    for (Map.Entry<String, TransactionOutput> item: BlockChain.UTXOs.entrySet()){
        // ...
    }
    // ...
    for(TransactionInput input: inputs){
        BlockChain.UTXOs.remove(input.transactionOutputId);
    }
    return newTransaction;
}

// 수정 후
public Transaction sendFunds(PublicKey _recipient, float value) {
    // ...
    for (Map.Entry<String, TransactionOutput> item: UTXOs.entrySet()){
        // ...
    }
    // ...
    for(TransactionInput input: inputs){
        UTXOs.remove(input.transactionOutputId);
    }
    return newTransaction;
}
```

## 2. `Transaction.java`

### 문제점
- `calulateHash` 메소드의 이름에 오타가 있었습니다.

### 수정 내용
- `calulateHash` -> `calculateHash`로 메소드 이름을 수정했습니다.

## 3. `MerkleRoot.java`

### 문제점
- 머클 트리를 구성할 때, 트랜잭션 해시를 쌍으로 묶어 해시하는 로직에 버그가 있었습니다. (`i++`로 인해 잘못된 노드 쌍을 해시)
- `treeLayer.getFirst()`는 `ArrayList`에 존재하지 않는 메소드라 컴파일 오류를 유발합니다.

### 수정 내용
- 머클 트리 생성 루프를 `for(int i=1; i < previousTreeLayer.size(); i+=2)`로 수정하여 노드를 올바르게 쌍으로 묶도록 했습니다.
- `treeLayer.getFirst()`를 `treeLayer.get(0)`으로 수정하여 컴파일 오류를 해결했습니다.

```java
// 수정 전
while(count > 1) {
    treeLayer = new ArrayList<String>();

    for(int i = 1; i < previousTreeLayer.size(); i++) {
        treeLayer.add(HashUtil.applySha256(previousTreeLayer.get(i-1) + previousTreeLayer.get(i)));
    }

    count = treeLayer.size();
    previousTreeLayer = treeLayer;
}
return (treeLayer.size() == 1) ? treeLayer.getFirst() : "";

// 수정 후
while(count > 1) {
    treeLayer = new ArrayList<String>();
    for(int i=1; i < previousTreeLayer.size(); i+=2) {
        treeLayer.add(HashUtil.applySha256(previousTreeLayer.get(i-1) + previousTreeLayer.get(i)));
    }
    count = treeLayer.size();
    previousTreeLayer = treeLayer;
}
String merkleRoot = (treeLayer.size() == 1) ? treeLayer.get(0) : "";
return merkleRoot;
```
